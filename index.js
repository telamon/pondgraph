const sos = require('save-our-sanity')
const { relative } = require('path')

class PondGraph {
  constructor (opts = {}) {
    this.interactions = []
    this.sources = []
    this.targets = []
    this.root = opts.root || process.cwd()
  }

  trace (label, obj) {
    return sos(obj, {
      logger: (op, prop, value) => {
        let trace = null
        try {
          throw new Error()
        } catch (e) { trace = e.stack.split('\n') }

        if (!trace[4]) throw new Error('Stacktrace is borked', trace)
        const exp = /\s+at ([^ ]+) (?:\[as (.+)\] )?\((.*):\d+:\d+\)/

        const m = trace[4].match(exp)

        if (!m) {
          // debugger
          throw new Error(`Unsupported trace line\n"${trace[4]}"`)
        }

        const caller = m[1]
        const path = m[3]
        const rpath = relative(this.root, path)
        const interaction = { caller, prop, op, value, ptime: process.uptime() }
        this.interactions.push(interaction)
        this.targets.push([label, prop])
        this.sources.push([rpath, caller])
      }
    })
  }

  _preGraph () {
    // filter non unique
    const targets = Object.values(this.targets.reduce((hm, tgt) => {
      hm[tgt.join(',')] = tgt
      return hm
    }, {}))
    const sources = Object.values(this.sources.reduce((hm, src) => {
      hm[src.join(',')] = src
      return hm
    }, {}))
    return {
      targets,
      sources,
      events: this.interactions.map(i => Object.assign({}, i))
    }
  }

  toDot (label="pondgraph", opts = {}) {
    const { sources, targets, events } = this._preGraph()
    const lines = [`digraph G {
      // Generated by pondgraph
      graph [fontname="fixed",overlap=${opts.overlap ? 'true' : 'false'},label="${label}"];
      node [style=filled,fillcolor=white,shape=box];
    `]

    lines.push('// sources')
    for (const [rpath, caller] of sources) {
      lines.push(`"${rpath}" -> "${caller}";`)
    }

    lines.push('// interactions / events')
    lines.push('{ node[fillcolor=SkyBlue,shape=oval]')
    for (const {caller, prop, op} of events) {
      lines.push(`"${caller}" -> "${prop}"[label="${op}"];`)
    }
    lines.push('}')


    lines.push('// targets')
    lines.push('{ node[fillcolor=orange]')
    lines.push('edge[arrowhead=none,arrowtail=none]')
    for (const [entLabel, prop] of targets) {
      lines.push(`"${entLabel}" -> "${prop}";`)
    }
    lines.push('}')

    lines.push('}')
    return lines.join('\n')
  }
}

module.exports = PondGraph
